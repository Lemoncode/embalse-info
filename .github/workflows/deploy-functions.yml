name: Deploy Azure Functions

on:
  push:
    branches: ["main"]

concurrency:
  group: functions-prod
  cancel-in-progress: true

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest

    steps:
      # Checkout repository source code
      - name: Checkout
        uses: actions/checkout@v4

      # Setup Node.js runtime
      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: "22"
          cache: "npm"

      # Install all monorepo dependencies (npm workspaces)
      - name: Install dependencies
        run: npm ci

      # Build all workspace packages first (db, db-model, arcgis, etc.)
      # This ensures all internal dependencies generate their dist and type declarations
      - name: Build all internal packages
        run: npm run build

      # Build ONLY the functions workspace (TypeScript -> dist/)
      # This runs clean + type-check + build
      - name: Build functions workspace
        run: npm run -w functions ci

      # Prepare a clean deployment folder that Azure expects.
      # Azure Functions requires host.json at the root.
      # We also copy compiled dist output and the internal db package.
      - name: Prepare deploy folder
        run: |
          rm -rf deploy
          mkdir -p deploy/packages

          # Copy required runtime files
          cp functions/host.json deploy/host.json
          cp -R functions/dist deploy/dist

          # Copy the internal workspace package so it can be installed via "file:"
          cp -R packages/db deploy/packages/db

          # Strip devDependencies from the copied db package
          # so npm doesn't try to resolve workspace-only packages
          node -e "
            const fs = require('fs');
            const p = 'deploy/packages/db/package.json';
            const pkg = JSON.parse(fs.readFileSync(p,'utf8'));
            delete pkg.devDependencies;
            fs.writeFileSync(p, JSON.stringify(pkg, null, 2));
          "

          # Generate a deploy-specific package.json.
          # We inject a file-based dependency so Azure can install the internal package.
          node -e "
            const fs = require('fs');
            const pkg = JSON.parse(fs.readFileSync('functions/package.json','utf8'));
            pkg.name = 'functions-deploy';
            pkg.main = 'dist/index.js';
            pkg.dependencies = pkg.dependencies || {};
            pkg.dependencies['@embalse-info/db'] = 'file:./packages/db';
            fs.writeFileSync('deploy/package.json', JSON.stringify(pkg, null, 2));
          "

          # Install only production dependencies inside deploy/
          # This creates deploy/node_modules ready for Azure runtime
          cd deploy
          npm install --omit=dev --ignore-scripts

      # Create deployment zip
      - name: Create deployment package
        run: cd deploy && zip -r ../deploy.zip .

      # Deploy using Azure CLI (avoids Kudu zipdeploy issues)
      - name: Deploy to Azure Functions
        run: |
          # Extract SCM credentials from publish profile
          PUBLISH_PROFILE='${{ secrets.AZURE_FUNCTIONAPP_PUBLISH_PROFILE }}'
          SCM_USER=$(echo "$PUBLISH_PROFILE" | grep -o 'userName="[^"]*"' | head -1 | sed 's/userName="//;s/"//')
          SCM_PASS=$(echo "$PUBLISH_PROFILE" | grep -o 'userPWD="[^"]*"' | head -1 | sed 's/userPWD="//;s/"//')
          SCM_URL=$(echo "$PUBLISH_PROFILE" | grep -o 'publishUrl="[^"]*"' | head -1 | sed 's/publishUrl="//;s/"//')

          echo "Deploying to https://${SCM_URL}/api/publish..."
          HTTP_STATUS=$(curl -s -o /dev/stderr -w "%{http_code}" \
            -X POST "https://${SCM_URL}/api/publish" \
            -u "${SCM_USER}:${SCM_PASS}" \
            -H "Content-Type: application/zip" \
            --data-binary @deploy.zip)

          echo "HTTP Status: ${HTTP_STATUS}"
          if [ "$HTTP_STATUS" -ge 200 ] && [ "$HTTP_STATUS" -lt 300 ]; then
            echo "Deployment successful!"
          else
            echo "Deployment failed with status ${HTTP_STATUS}"
            exit 1
          fi
